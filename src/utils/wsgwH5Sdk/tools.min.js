
import sm from './lib/sm-crypto/index'
import {
  Sm4js
} from './sm4js.js'
import envConfig from './env_config'
let isDebug =  true //是否开启公共方法日志打印
let cipherMode = 1 //sm2加密方式
let sm4AlgoriType = 'ecb' //sm4加密模式 ebc cbc

// 字符串截取 中2 英1         // 起(不包含)   截取字符个数(包含)   '中国人ABC'._slice(2, 3)不出字
String.prototype._slice = function (start = 0, characterNum) {

  var str = this;
  if (str && str.length) {
    var stringArr = str.split('');
    var resultStr = '';
    var realLength = 0;
    resultStr = stringArr.filter((item, idnex) => {

      var charCode = str.charCodeAt(idnex);
      if (charCode >= 0 && charCode <= 128) {
        realLength = realLength + 1
      } else {
        realLength = realLength + 2;
      }
      return realLength > start && realLength <= characterNum
    });
    return resultStr.join('');
  } else {
    console.error('tools.js  _slice,传入参数错误', str);
  }
};
// 判断字符串长度
String.prototype.GetLength = function () {
  ///<summary>获得字符串实际长度，中文2，英文1</summary>
  ///<param name="str">要获得长度的字符串</param>
  var str = this;
  var realLength = 0,
    len = str.length,
    charCode = -1;
  for (var i = 0; i < len; i++) {
    charCode = str.charCodeAt(i);
    if (charCode >= 0 && charCode <= 128)
      realLength += 1;
    else
      realLength += 2;
  }
  return realLength;
};

// 变量
const sm2 = sm.sm2;
const sm3 = sm.sm3;
const keyPairHex = sm2.generateKeyPairHex(); //获取公钥私钥对象
// const publicKey = keyPairHex.publicKey; // 公钥
// const privateKey = keyPairHex.privateKey; // 私钥



const tools = {
  // 获取接口地址公共url
  getCommonApiUrl() {
    let url = ''
    return url;
  },

  // 加密对象每个值
  // encryptEachparam(data) {
  //   Object.keys(data).forEach(key => {
  //     if (Object.prototype.toString.call(key) === '[object Array]') {
  //       data[key] = JSON.stringify(data[key]) // 这里必须使用内置JSON对象转换
  //     } else if (typeof data[key] === 'object') {
  //       tools.encryptEachparam(data[key])
  //     } else {
  //       data[key] = tools.encryptData(data[key])
  //     }
  //   })
  //   return data;
  // },

  // 解密 对象里每个参数
  // decryptEachparam(data) {
  //   Object.keys(data).forEach(key => {
  //     if (Object.prototype.toString.call(key) === '[object Array]') {
  //       data[key] = JSON.stringify(data[key]) // 这里必须使用内置JSON对象转换
  //     } else if (typeof data[key] === 'object') {
  //       tools.decryptEachparam(data[key])
  //     } else {
  //       data[key] = tools.doDecrypt(data[key])
  //     }
  //   })
  //   return data;
  // },

  // 加密 字符串或一个对象 'a' || {a: '1'}
  encryptData(msgString) {
    let params;
    if (Object.prototype.toString.call(msgString) === "[object Object]") {
      params = JSON.stringify(msgString)
    } else {
      params = msgString
    }

    let newParams = sm2.doEncrypt(params, envConfig.publicKey, cipherMode);
    if (newParams != "" && newParams != undefined) {
      newParams = "04" + newParams;
    }

    return newParams;
  },
  encryptBodyData(key, msgString) {

    let params;
    if (Object.prototype.toString.call(msgString) === "[object Object]") {
      params = JSON.stringify(msgString)
    } else {
      params = msgString
    }
    var sm4Config = {
      key: key, //this.randomkey(false, 16),
      mode: sm4AlgoriType,
      iv: "", //this.randomkey(false, 16),
      cipherType: 'base64'
    };
    this.debug("sm4Config=", JSON.stringify(sm4Config));
    var sm4 = new Sm4js(sm4Config);
    let newParams = sm4.encrypt(params);
    return newParams;
  },

  // 解密 字符串或一个对象 'a' || {a: '1'}
  // doDecrypt(data) {
  //   if (data == undefined) {
  //     return undefined
  //   }
  //   if (data == "") {
  //     return undefined
  //   }
  //   //console.log(data);

  //   //let hexData = smUtil.sm2Decrypt(data, cyu.privateKey);
  //   var tag = data.substr(0, 2);
  //   if (tag != "04") {
  //     return undefined
  //   }
  //   data = data.substr(2).toLowerCase();
  //   let resData = sm2.doDecrypt(data, privateKey.toLowerCase(), cipherMode); 
  //   //let resData = tools.hexToString(hexData);
  //   // console.log(resData);
  //   return resData;
  // }, // 解密 字符串或一个对象 'a' || {a: '1'}
  doDecryptBodyData(key, data) {
    if (data == undefined) {
      return this.responseDecryptoError();
    }
    if (data == "") {
      return this.responseDecryptoError();
    }
    var sm4Config = {
      key: key, //this.randomkey(false, 16),
      mode: sm4AlgoriType,
      iv: "", //this.randomkey(false, 16),
      cipherType: 'base64'
    };
    var sm4 = new Sm4js(sm4Config);
    let resData = sm4.decrypt(data);
    return resData;
    // return JSON.parse(resData);
  },

  //签名
  signData(data) {
    if (data == undefined) {
      return undefined
    }
    if (data == "") {
      return undefined
    }
    return sm3(data);
  },


  stringToHex: function (data) {
    if (data === "")
      return "";
    return tools.bytesToHex(tools.strToBytes(data));
  },

  strToBytes: function (data) {
    let result = new Array();

    let k = 0;
    for (let i = 0; i < data.length; i++) {
      var j = encodeURI(data[i]);
      if (j.length == 1) {
        // 未转换的字符
        result[k++] = j.charCodeAt(0);
      } else {
        // 转换成%XX形式的字符
        let bytes = j.split("%");
        for (var l = 1; l < bytes.length; l++) {
          result[k++] = parseInt("0x" + bytes[l]);
        }
      }
    }
    // console.log(result);
    return result;
  },

  bytesToHex: function (arr) {
    let str = "";
    for (let i = 0; i < arr.length; i++) {
      let tmp = arr[i].toString(16);
      if (tmp.length == 1) {
        tmp = "0" + tmp;
      }
      str += tmp;
    }
    // console.log(str);
    return str;
  },

  hexToString: function (data) {
    //hex="e68980e7bb8f313253"
    let tmp = '';
    if (data.length % 2 == 0) {
      for (let i = 0; i < data.length; i += 2) {
        tmp += '%' + data.charAt(i) + data.charAt(i + 1);
      }
    }
    // console.log(decodeURIComponent(tmp));
    return decodeURIComponent(tmp);
  },

  getCansValue: function (canvas) {
    // var canvas = document.createElement('canvas');

    var ctx = canvas.getContext('2d');
    var txt = 'http://www.95598.cn/';
    ctx.textBaseline = "top";
    ctx.font = "14px 'Arial'";
    ctx.textBaseline = "tencent";
    ctx.fillStyle = "#f60";
    ctx.fillRect(125, 1, 62, 20);
    ctx.fillStyle = "#069";
    ctx.fillText(txt, 2, 15);
    ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
    ctx.fillText(txt, 4, 17);

    var b64 = canvas.toDataURL().replace("data:image/png;base64,", "");
    var bin = atob(b64);
    var crc = tools.binToHex(bin.slice(-16, -12));
    //var crc = bin.slice(-16,-12);
    return crc;
  },

  binToHex: function (data) {
    var result = "";
    for (let i = 0; i < data.length; i++) {
      result += tools.int16ToHex(data.charCodeAt(i));
    }
    return result;
  },
 uuid(url) {
  var s = [];
  var hexDigits = url;
  for (var i = 0; i < 36; i++) {
      s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
  }
  s[14] = "4"; // bits 12-15 of the time_hi_and_version field to 0010
  s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01
  s[8] = s[13] = s[18] = s[23] = "-";

  var uuid = s.join("");
  return uuid;
  },

  int16ToHex: function (i) {
    var result = i.toString(16);
    var j = 0;
    while (j + result.length < 4) {
      result = "0" + result;
      j++;
    }
    return result;
  },

  // 字符串转数字
  string2number(val) {
    let res = '';
    if (val && typeof val === 'string') {
      res = Number.parseFloat(val);
    } else if (typeof val === 'number') {
      res = val;
    } else {
      res = val;
    }
    return res;
  },
  // 首字母大写
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  },
  // 时间戳格式转化 2018-07-30 11:11:11
  dataYMDHSS: function (timestamp) {
    if (!timestamp) {
      return '--'
    }
    var date = new Date(timestamp); //时间戳为10位需*1000，时间戳为13位的话不需乘1000
    var Y = date.getFullYear();
    var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1);
    var D = (date.getDate() < 10 ? ('0' + date.getDate()) : date.getDate());
    var h = (date.getHours() < 10 ? ('0' + date.getHours()) : date.getHours());
    var m = (date.getMinutes() < 10 ? ('0' + date.getMinutes()) : date.getMinutes());
    var s = date.getSeconds() < 10 ? ('0' + date.getSeconds()) : date.getSeconds();
    return `${Y}-${M}-${D} ${h}:${m}:${s}`;
  },
    /********************************************************
   * @description 五位省码转六位省码
   * @default
   */
     changeToPcode6:  (provinceId )=> {
      switch (provinceId) {
        case "11102": return "110000"; // 北京市
        case "12101": return "120000"; // 天津市
        case "31102": return "310000"; // 上海市
        case "50101": return "500000"; // 重庆市
        case "13102": return "130000"; // 河北省
        case "13103": return "130000"; // 冀北
        case "14101": return "140000"; // 山西省
        case "15101": return "150000"; // 内蒙古自治区
        case "21102": return "210000"; // 辽宁省
        case "22101": return "220000"; // 吉林省
        case "23101": return "230000"; // 黑龙江省
        case "32101": return "320000"; // 江苏省
        case "33101": return "330000"; // 浙江省
        case "34101": return "340000"; // 安徽省
        case "35101": return "350000"; // 福建省
        case "36101": return "360000"; // 江西省
        case "37101": return "370000"; // 山东省
        case "41101": return "410000"; // 河南省
        case "42102": return "420000"; // 湖北省
        case "43101": return "430000"; // 湖南省
        case "51101": return "510000"; // 四川省
        case "54101": return "540000"; // 西藏自治区
        case "61102": return "610000"; // 陕西省
        case "62101": return "620000"; // 甘肃省
        case "63101": return "630000"; // 青海省
        case "64101": return "640000"; // 宁夏回族自治区
        case "65101": return "650000"; // 新疆维吾尔自治区
        default:
          return "";              // 浙江
      }
    },
      /********************************************************
   * @description 六位省码转五位省码
   * @default
   */
   changeToPcode5: (provinceId) => {
    switch (provinceId) {
      case "110000": return "11102"; // 北京市
      case "120000": return "12101"; // 天津市
      case "310000": return "31102"; // 上海市
      case "500000": return "50101"; // 重庆市
      case "130000": return "13102"; // 河北省
      case "999999": return "13103"; // 冀北
      case "140000": return "14101"; // 山西省
      case "150000": return "15101"; // 内蒙古自治区
      case "210000": return "21102"; // 辽宁省
      case "220000": return "22101"; // 吉林省
      case "230000": return "23101"; // 黑龙江省
      case "320000": return "32101"; // 江苏省
      case "330000": return "33101"; // 浙江省
      case "340000": return "34101"; // 安徽省
      case "350000": return "35101"; // 福建省
      case "360000": return "36101"; // 江西省
      case "370000": return "37101"; // 山东省
      case "410000": return "41101"; // 河南省
      case "420000": return "42102"; // 湖北省
      case "430000": return "43101"; // 湖南省
      case "510000": return "51101"; // 四川省
      case "540000": return "54101"; // 西藏自治区
      case "610000": return "61102"; // 陕西省
      case "620000": return "62101"; // 甘肃省
      case "630000": return "63101"; // 青海省
      case "640000": return "64101"; // 宁夏回族自治区
      case "650000": return "65101"; // 新疆维吾尔自治区
      default:
        return "";              // 浙江
    }
  },
  // 时间戳格式转化 2018-07-30
  dataYMD: function (timestamp) {
    if (!timestamp) {
      return '--'
    }
    var date = new Date(timestamp); //时间戳为10位需*1000，时间戳为13位的话不需乘1000
    // var Y = date.getFullYear() + '-';
    // var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
    // var D = date.getDate() + ' ';

    // return Y + M + D;
    var Y = date.getFullYear();
    var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1);
    var D = (date.getDate() < 10 ? ('0' + date.getDate()) : date.getDate());

    return `${Y}-${M}-${D}`;
  },

  // 时间戳格式转化 2018-07
  dataYM: function (timestamp) {
    if (!timestamp) {
      return '--'
    }
    var date = new Date(timestamp); //时间戳为10位需*1000，时间戳为13位的话不需乘1000
    // var Y = date.getFullYear() + '-';
    // var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
    // var D = date.getDate() + ' ';

    // return Y + M ;
    var Y = date.getFullYear();
    var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1);
    // var D = (date.getDate() < 10 ? ('0' + date.getDate()) : date.getDate());

    return `${Y}-${M}`;
  },

  // 时间戳转化为 12：03
  dataHMS: function (timestamp) {
    if (!timestamp) {
      return '--'
    }
    var date = new Date(timestamp); //时间戳为10位需*1000，时间戳为13位的话不需乘1000
    // var h = date.getHours() + ':';
    // var m = date.getMinutes() + ':';
    // var s = date.getSeconds();
    // return h + m + s;

    var h = (date.getHours() < 10 ? ('0' + date.getHours()) : date.getHours());
    var m = (date.getMinutes() < 10 ? ('0' + date.getMinutes()) : date.getMinutes());
    var s = date.getSeconds() < 10 ? ('0' + date.getSeconds()) : date.getSeconds();
    return `${h}:${m}:${s}`;
  },
  // 时间对象转为 时间戳  (Tue Jul 03 2018 00:00:00 GMT+0800 (中国标准时间))
  date2GetTime: function (dateObje) {
    if (dateObje) {
      return new Date(dateObje).getTime();
    } else {
      return '';
    }

  },
  // 数字3位,分隔    小数点保留后2位
  bitSplit3: function (num) {
    var dotNum = (num || 0).toString().split('.')[1] || '';
    var num = (num || 0).toString().split('.')[0] || '',
      result = '';

    while (num.length > 3) {
      result = ',' + num.slice(-3) + result;
      num = num.slice(0, num.length - 3);
    }
    if (num) {
      result = num + result;
    }
    // 如果  有小数位                          如果没有小数位
    return dotNum ? result + '.' + dotNum : result + '.00';
  },
  // 数字3位,分隔  小数点保留后2位  解决负数问题
  bitSplit3s: function (num) {
    return new BigNumber(num).toFormat(2);
  },
  // 分转元           后面方法提供：数字3位,分隔  小数点保留后2位  解决负数问题
  bitSplit3Fen2Yuan: function (num) {
    if (!(Object.prototype.toString.call(num) === '[object String]' || Object.prototype.toString.call(num) === '[object Number]') && isNaN(parseFloat(num))) {
      console.error('filter.js    bitSplit3Fen2Yuan    请后台传入数字或字符串类型数据,当前数据为', num);
      return 0;
    }
    let tempNum = num;
    let resNum = undefined;
    if (Object.prototype.toString.call(num) === '[object String]') {
      tempNum = parseFloat(num);
    }

    tempNum = new BigNumber(tempNum); // 转完是字符串类型

    resNum = tempNum.div(100).toNumber(); // 除法
    return filter.bitSplit3s(resNum);
  },
  // 加￥符号       后面方法：分转元  数字3位,分隔  小数点保留后2位  解决负数问题
  bitSplit3Fen2YuanAddRMB: function (num) {
    return '￥' + filter.bitSplit3Fen2Yuan(num);
  },


  // 分转元
  fen2Yuan(num) {
    if (!(Object.prototype.toString.call(num) === '[object String]' || Object.prototype.toString.call(num) === '[object Number]') && isNaN(parseFloat(num))) {
      console.error('filter.js    fen2Yuan    请传入数字或字符串类型数字数据,当前数据为', num);
      return num;
    }
    let tempNum = num;
    let resNum = undefined;
    if (Object.prototype.toString.call(num) === '[object String]') {
      tempNum = parseFloat(num);
    }

    tempNum = new BigNumber(tempNum); // 转完是字符串类型

    resNum = tempNum.div(100).toNumber();
    return resNum;
  },
  // 元转分
  yuan2Fen(num) {
    if (!(Object.prototype.toString.call(num) === '[object String]' || Object.prototype.toString.call(num) === '[object Number]') && isNaN(parseFloat(num))) {
      console.error('filter.js    yuan2Fen    请传入数字或字符串类型数字数据,当前数据为', num);
      return num;
    }
    let tempNum = num;
    let resNum = undefined;
    if (Object.prototype.toString.call(num) === '[object String]') {
      tempNum = parseFloat(num);
    }

    tempNum = new BigNumber(tempNum); // 转完是字符串类型

    resNum = tempNum.multipliedBy(100).toNumber();
    return resNum;
  },
  // 格式化手机
  forMatPhone: function (phone) {
    if (/^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\d{8}$/.test(phone)) {
      return ('' + phone).replace(/(\d{3})(\d{4})(\d{4})/, ($1, $2, $3, $4) => {
        return $2 + ' *** ' + $4
      })
    } else {
      return phone;
    }

  },

  // 去除两边空格
  Trim: function (val) {
    if (val && Object.prototype.toString.call(val) === '[object String]') {
      return val.Trim();
    } else {
      console.error('tools.js   Trim   请传入字符串类型数据,当前数据为', val);
    }
  },
  // 去除左边空格
  LTrim: function (val) {
    if (val && Object.prototype.toString.call(val) === '[object String]') {
      return val.LTrim();
    } else {
      console.error('tools.js   LTrim   请传入字符串类型数据,当前数据为', val);
    }
  },
  // 去除右边空格
  RTrim: function (val) {
    if (val && Object.prototype.toString.call(val) === '[object String]') {
      return val.RTrim();
    } else {
      console.error('tools.js   RTrim   请传入字符串类型数据,当前数据为', val);
    }
  },
  // 计算string的中文英文字符长度    (中文2 英文1)
  GetLength: function (val) {
    if (val && Object.prototype.toString.call(val) === '[object String]') {
      return val.GetLength();
    } else {
      console.error('tools.js   GetLength   请传入字符串类型数据,当前数据为', val);
    }
  },
  // 通过 router参数 查找当前路由对象
  findUrlByRouterParmas: function (parmas = {
    name: ''
  }) {
    if (Object.prototype.toString.call(parmas.name) !== '[object String]') {
      console.error('router.name入参错误,请传入string类型,当前值为:    ', parmas.name);
      return false;
    }
    if (parmas.name.Trim() === '') {
      console.error('跳转name传值不能为空字符串');
      return false;
    }
    let routeData = this.$router.resolve(parmas);
    return routeData;
  },
  /**
   * 生成随机字符
   * @param {*} randomFlag 是否基于范围生成
   * @param {*} min 最小生成数量
   * @param {*} max 最大生成数量
   * 忽略了其他代码，只写了如何调用
   * 生成4-16位随机串
   * randomWord(true, 4, 16)
   * 生成24位的随机串
   * randomWord(false, 24)
   */
  randomkey: function (randomFlag, min, max) {
    let str = '',
      range = min, // 默认赋值为第二个参数，如果是随机产生位数会通过下面的if改变。
      arr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];

    // 随机产生
    if (randomFlag) {
      range = Math.round(Math.random() * (max - min)) + min;
    }
    for (let i = 0; i < range; i++) {
      let index = Math.round(Math.random() * (arr.length - 1));
      str += arr[index];
    }
    return str;
  },
  xorkey: function (key) {
    var result = new Array();
    for (var i = 0; i < key.length; i += 8) {
      result.push(parseInt(key.slice(i, i + 8), 16))
    }
    return result;
  },

  bigxor: function (a, b) {
    var abin = a.toString(2);
    var bbin = b.toString(2);
    var loggest = abin.length >= bbin.length ? abin.length : bbin.length;
    abin = abin.length == loggest ? abin : "0".repeat(loggest - abin.length) + abin;
    bbin = bbin.length == loggest ? bbin : "0".repeat(loggest - bbin.length) + bbin;
    var result = "";
    for (var i = loggest - 1; i >= 0; i--) {
      result = abin[i] == bbin[i] ? '0' + result : '1' + result;
    };
    return parseInt(result, 2);
  },
  // 封装的console.log打印
  debug: (title, message) => {
    if (isDebug) {
      console.log( title || "debugTitle===>", message || "debugMessage");
    }
  },
  responseDecryptoError: () => {
    return {
      "code": "0",
      "data": {},
      "message": "温馨提示：用户操作异常，请稍后再试！"
    };
  },


}

function bigxor(a, b) {
  var abin = a.toString(2);
  var bbin = b.toString(2);
  var loggest = abin.length >= bbin.length ? abin.length : bbin.length;
  abin = abin.length == loggest ? abin : "0".repeat(loggest - abin.length) + abin;
  bbin = bbin.length == loggest ? bbin : "0".repeat(loggest - bbin.length) + bbin;
  var result = "";
  for (var i = loggest - 1; i >= 0; i--) {
    result = abin[i] == bbin[i] ? '0' + result : '1' + result;
  };
  return parseInt(result, 2);
}

function xorkey(key) {
  var result = new Array();
  for (var i = 0; i < key.length; i += 8) {
    result.push(parseInt(key.slice(i, i + 8), 16))
  }
  return result;
}

export default tools;
